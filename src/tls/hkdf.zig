const std = @import("std");
const math = std.math;
const mem = std.mem;
const crypto = @import("crypto.zig");
const HashType = @import("auth.zig").HashType;

// Extract generates a pseudorandom key for use with Expand from an input secret
// and an optional independent salt.
//
// Only use this function if you need to reuse the extracted key with multiple
// Expand invocations and different context values. Most common scenarios,
// including the generation of multiple keys, should use New instead.
pub fn extract(
    hash_type: HashType,
    allocator: mem.Allocator,
    secret: []const u8,
    salt: ?[]const u8,
) ![]const u8 {
    var salt2 = salt orelse blk: {
        var s = try allocator.alloc(u8, hash_type.digestLength());
        mem.set(u8, s, 0);
        break :blk s;
    };
    defer if (salt == null) allocator.free(salt2);

    var out = try allocator.alloc(u8, hash_type.digestLength());
    switch (hash_type) {
        .sha256 => {
            const HmacSha256 = std.crypto.auth.hmac.sha2.HmacSha256;
            HmacSha256.create(out[0..HmacSha256.mac_length], secret, salt2);
        },
        .sha384 => {
            const HmacSha384 = std.crypto.auth.hmac.sha2.HmacSha384;
            HmacSha384.create(out[0..HmacSha384.mac_length], secret, salt2);
        },
        .sha512 => {
            const HmacSha512 = std.crypto.auth.hmac.sha2.HmacSha512;
            HmacSha512.create(out[0..HmacSha512.mac_length], secret, salt2);
        },
        .sha1 => {
            const HmacSha1 = std.crypto.auth.hmac.HmacSha1;
            HmacSha1.create(out[0..HmacSha1.mac_length], secret, salt2);
        },
        else => @panic("unsupported hash_type for hdkf.extract"),
    }
    return out;
}

pub fn Hkdf(comptime Hash: type) type {
    return struct {
        pub const Error = error{EntropyLimitReached};
        pub const Reader = std.io.Reader(*Self, Error, read);

        const Self = @This();
        const Hmac = std.crypto.auth.hmac.Hmac(Hash);

        pseudorandom_key: []const u8,
        owns_pseudorandom_key: bool,
        // Hdkf does not own info.
        info: []const u8,
        counter: u8,

        prev: [Hmac.mac_length]u8 = undefined,
        prev_pos: usize = Hmac.mac_length,
        buf: [Hmac.mac_length]u8 = undefined,
        buf_pos: usize = Hmac.mac_length,

        // Expand returns a Hkdf(Hash), from which keys can be read, using the given
        // pseudorandom key and optional context info, skipping the extraction step.
        //
        // The pseudorandomKey should have been generated by Extract, or be a uniformly
        // random or pseudorandom cryptographically strong key. See RFC 5869, Section
        // 3.3. Most common scenarios will want to use New instead.
        //
        // caller must keep pseudorandom_key and info until the use of Hkdf(Hash) is finished.
        pub fn expand(pseudorandom_key: []const u8, info: []const u8) Self {
            return .{
                .pseudorandom_key = pseudorandom_key,
                .owns_pseudorandom_key = false,
                .info = info,
                .counter = 1,
            };
        }

        // New returns a Reader, from which keys can be read, using the given hash,
        // secret, salt and context info. Salt and info can be nil.
        //
        // caller must keep info until the use of Hkdf(Hash) is finished.
        pub fn new(allocator: mem.Alocator, secret: []const u8, salt: []const u8, info: []const u8) Self {
            const prk = try extract(allocator, secret, salt);
            return .{
                .pseudorandom_key = prk,
                .owns_pseudorandom_key = true,
                .info = info,
                .counter = 1,
            };
        }

        pub fn deinit(self: *Self, allocator: mem.Allocator) void {
            if (self.owns_pseudorandom_key) allocator.free(self.pseudorandom_key);
        }

        pub fn read(self: *Self, buffer: []u8) Error!usize {
            std.log.debug("Hmac.mac_length={}", .{Hmac.mac_length});
            // Check whether enough data can be generated
            const need = buffer.len;
            const remains = (self.buf.len - self.buf_pos) + (255 - self.counter + 1) * Hmac.mac_length;
            if (remains < need) {
                return error.EntropyLimitReached;
            }
            // Read any leftover from the buffer
            var n = math.min(buffer.len, self.buf.len - self.buf_pos);
            mem.copy(u8, buffer, self.buf[self.buf_pos .. self.buf_pos + n]);
            var dest_pos: usize = n;
            std.log.debug("dest_pos={}", .{dest_pos});

            // Fill the rest of the buffer
            while (dest_pos < buffer.len) {
                var expander = Hmac.init(self.pseudorandom_key);
                expander.update(self.prev[self.prev_pos..]);
                expander.update(self.info);
                expander.update(&[_]u8{self.counter});
                expander.final(self.prev[0..]);
                self.prev_pos = 0;
                std.log.debug("counter={}, prev={}", .{ self.counter, std.fmt.fmtSliceHexLower(&self.prev) });
                self.counter +%= 1;

                // Copy the new batch into p
                mem.copy(u8, &self.buf, &self.prev);
                self.buf_pos = 0;
                n = math.min(buffer.len - dest_pos, self.buf.len);
                mem.copy(u8, buffer[dest_pos..], self.buf[0..n]);
                dest_pos += n;
            }
            // Save leftovers for next run
            self.buf_pos = n;
            return need;
        }

        pub fn reader(self: *Self) Reader {
            return .{ .context = self };
        }
    };
}

const testing = std.testing;

test "Hkdf.expand" {
    testing.log_level = .err;
    const secret = "\x56\xbc\x08\x69\xe1\x4d\xd4\x00\xca\x53\x9f\x09\x04\x66\x62\xb8\x24\x63\x66\xf9\xfd\x41\xf4\x11\x80\xde\x07\xab\x5b\x50\x4c\x70";
    const hkdf_label = "\x00\x20\x12\x74\x6c\x73\x31\x33\x20\x63\x20\x68\x73\x20\x74\x72\x61\x66\x66\x69\x63\x20\x41\x44\x4f\x05\x04\x2e\x45\x58\xd3\x9c\x02\x0a\xb3\x49\x33\x08\x79\x75\x4b\xf8\x7a\xab\x30\x88\x3b\xa3\x70\xee\x2f\xad\x31\x2b";
    const HkdfSha256 = Hkdf(std.crypto.hash.sha2.Sha256);
    var hkdf_reader = HkdfSha256.expand(secret, hkdf_label);
    const length: usize = 32;
    var out: [length]u8 = undefined;
    var n = try hkdf_reader.read(&out);

    const want = "\x82\x05\x2b\xb2\x02\x21\xf4\x1b\x89\x5b\xd6\xb4\x9f\xd1\x67\x9f\xe8\x38\xde\x55\xc8\xab\x3f\x9c\x17\xc4\x50\x56\x15\xe9\x7b\x61";
    try testing.expectEqualSlices(u8, want, &out);
    try testing.expectEqual(length, n);
}

// 2022/02/21 13:22:12 cipherSuiteTLS13.expandLabel start secret=56bc0869e14dd400ca539f09046662b8246366f9fd41f41180de07ab5b504c70, label=c hs traffic, context=41444f05042e4558d39c020ab349330879754bf87aab30883ba370ee2fad312b, length=32
// 2022/02/21 13:22:12 cipherSuiteTLS13.expandLabel hkdfLabelBytes=002012746c733133206320687320747261666669632041444f05042e4558d39c020ab349330879754bf87aab30883ba370ee2fad312b
// 2022/02/21 13:22:12 cipherSuiteTLS13.expandLabel out=82052bb20221f41b895bd6b49fd1679fe838de55c8ab3f9c17c4505615e97b61
