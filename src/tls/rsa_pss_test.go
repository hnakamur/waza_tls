package main

import (
	"bytes"
	"crypto"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"errors"
	"hash"
	"log"
	"math/big"
	"testing"
)

func TestEmsaPSSEncode(t *testing.T) {
	mHash := []byte("\x7f\xdd\xeb\x8d\x8a\x9e\x4c\x5e\x2e\x7e\x8c\x13\x5a\xb8\xf8\xb6\x19\xba\x21\xae\xb5\x2d\x61\xba\x85\xeb\x1e\x29\x28\x32\xe6\x81")
	emBits := 2047
	salt := []byte("\xc4\xd8\x67\x64\x3b\xf8\xdc\x07\xd4\xb0\x0b\x3b\x4c\x36\x21\x1b\x57\xa6\x9d\xf9\x78\x78\x6a\xfd\xe9\xea\x94\x88\x85\xfd\x59\xfd")
	got, err := emsaPSSEncode(mHash, emBits, salt, sha256.New())
	if err != nil {
		t.Fatal(err)
	}
	want := []byte("\x59\x08\x28\xf1\xae\x1c\x6d\x71\x5e\x6f\xd7\x63\xb3\x6c\xef\x35\x59\x20\x00\x04\x95\xde\x46\xfc\x01\x2f\x11\x3d\x20\x23\x73\xec\xdd\xd3\xbd\xda\x1f\x75\x4d\x56\xc7\x7b\xe7\x84\x73\x97\x58\x71\xeb\x4f\x37\xff\xa0\x22\x36\xfa\x0e\x81\x91\x1c\xb1\xbb\xc3\x01\x59\x80\xc0\x9e\x04\x1c\x9f\x20\xe2\x42\x8c\xbc\xc8\x8c\xab\x3a\x74\xf6\x95\x30\x76\xb6\x34\x93\x97\x3c\x6d\x74\x1e\xc1\xd3\xbd\x9d\x61\x4b\x9d\xea\x9f\xff\xef\x71\x70\xfe\xbe\xc6\xeb\xfc\xba\x18\x15\xb8\x54\x6c\x8b\xa3\x81\x1e\x3f\xe0\x3e\x9b\x5d\x94\x74\xca\x0c\xcf\x89\x86\x1f\x60\xbd\x13\xc8\x34\x30\x5b\xd5\x89\xab\x1f\x9c\xf8\xe8\x2d\x64\x6a\x59\x64\xfe\x5d\xe0\xcb\xbb\xa1\xf6\xba\x7d\xde\xe0\x7a\xd8\x58\xf8\xbb\x22\x53\x39\x12\xbd\x0e\xa3\xd3\x02\xa1\x38\x9d\xd7\x3d\xef\xb6\xea\x1f\xb1\xe8\xca\x64\x2e\x42\xde\x6a\xca\xd6\x26\xfa\xb0\x79\x00\xa3\x89\xe5\xa2\x07\x11\x6e\x8c\xdc\xac\x2a\xb3\xef\x9a\xcc\xc3\xd8\x87\x6a\x90\xf4\x42\xb7\x92\x6e\x21\x34\x40\x7c\x91\x9d\xa4\xb7\xa6\xae\xd2\x45\x1d\x4f\x6e\xe8\xaf\x21\x5c\xcc\xf0\x67\x58\x45\x46\x23\xaa\xcf\xbc")
	if !bytes.Equal(got, want) {
		t.Errorf("result mismatch, got=%x, want=%x", got, want)
	}
}

func emsaPSSEncode(mHash []byte, emBits int, salt []byte, hash hash.Hash) ([]byte, error) {
	log.Printf("emsaPSSEncode mHash=%x, emBits=%d, salt=%x", mHash, emBits, salt)
	// See RFC 8017, Section 9.1.1.

	hLen := hash.Size()
	sLen := len(salt)
	emLen := (emBits + 7) / 8

	// 1.  If the length of M is greater than the input limitation for the
	//     hash function (2^61 - 1 octets for SHA-1), output "message too
	//     long" and stop.
	//
	// 2.  Let mHash = Hash(M), an octet string of length hLen.

	if len(mHash) != hLen {
		return nil, errors.New("crypto/rsa: input must be hashed with given hash")
	}

	// 3.  If emLen < hLen + sLen + 2, output "encoding error" and stop.

	if emLen < hLen+sLen+2 {
		return nil, errors.New("crypto/rsa: key size too small for PSS signature")
	}

	em := make([]byte, emLen)
	psLen := emLen - sLen - hLen - 2
	db := em[:psLen+1+sLen]
	h := em[psLen+1+sLen : emLen-1]

	// 4.  Generate a random octet string salt of length sLen; if sLen = 0,
	//     then salt is the empty string.
	//
	// 5.  Let
	//       M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt;
	//
	//     M' is an octet string of length 8 + hLen + sLen with eight
	//     initial zero octets.
	//
	// 6.  Let H = Hash(M'), an octet string of length hLen.

	var prefix [8]byte

	hash.Write(prefix[:])
	hash.Write(mHash)
	hash.Write(salt)

	h = hash.Sum(h[:0])
	log.Printf("emsaPSSEncode updated h=%x", h)
	// h=42b7926e2134407c919da4b7a6aed2451d4f6ee8af215cccf06758454623aacf
	log.Printf("emsaPSSEncode updated db=%x", db)
	hash.Reset()

	// 7.  Generate an octet string PS consisting of emLen - sLen - hLen - 2
	//     zero octets. The length of PS may be 0.
	//
	// 8.  Let DB = PS || 0x01 || salt; DB is an octet string of length
	//     emLen - hLen - 1.

	db[psLen] = 0x01
	copy(db[psLen+1:], salt)

	// 9.  Let dbMask = MGF(H, emLen - hLen - 1).
	//
	// 10. Let maskedDB = DB \xor dbMask.

	mgf1XOR(db, hash, h)
	log.Printf("emsaPSSEncode after mgf1XOR, db=%x", db)
	// d90828f1ae1c6d715e6fd763b36cef355920000495de46fc012f113d202373ecddd3bdda1f754d56c77be78473975871eb4f37ffa02236fa0e81911cb1bbc3015980c09e041c9f20e2428cbcc88cab3a74f6953076b63493973c6d741ec1d3bd9d614b9dea9fffef7170febec6ebfcba1815b8546c8ba3811e3fe03e9b5d9474ca0ccf89861f60bd13c834305bd589ab1f9cf8e82d646a5964fe5de0cbbba1f6ba7ddee07ad858f8bb22533912bd0ea3d302a1389dd73defb6ea1fb1e8ca642e42de6acad626fab07900a389e5a207116e8cdcac2ab3ef9accc3d8876a90f4

	// 11. Set the leftmost 8 * emLen - emBits bits of the leftmost octet in
	//     maskedDB to zero.

	db[0] &= 0xff >> (8*emLen - emBits)

	// 12. Let EM = maskedDB || H || 0xbc.
	em[emLen-1] = 0xbc

	// 13. Output EM.
	log.Printf("emsaPSSEncode returns m, em=%x", em)
	// 590828f1ae1c6d715e6fd763b36cef355920000495de46fc012f113d202373ecddd3bdda1f754d56c77be78473975871eb4f37ffa02236fa0e81911cb1bbc3015980c09e041c9f20e2428cbcc88cab3a74f6953076b63493973c6d741ec1d3bd9d614b9dea9fffef7170febec6ebfcba1815b8546c8ba3811e3fe03e9b5d9474ca0ccf89861f60bd13c834305bd589ab1f9cf8e82d646a5964fe5de0cbbba1f6ba7ddee07ad858f8bb22533912bd0ea3d302a1389dd73defb6ea1fb1e8ca642e42de6acad626fab07900a389e5a207116e8cdcac2ab3ef9accc3d8876a90f442b7926e2134407c919da4b7a6aed2451d4f6ee8af215cccf06758454623aacfbc
	return em, nil
}

func TestMgf1XOR(t *testing.T) {
	out := []byte("\x59\x08\x28\xf1\xae\x1c\x6d\x71\x5e\x6f\xd7\x63\xb3\x6c\xef\x35\x59\x20\x00\x04\x95\xde\x46\xfc\x01\x2f\x11\x3d\x20\x23\x73\xec\xdd\xd3\xbd\xda\x1f\x75\x4d\x56\xc7\x7b\xe7\x84\x73\x97\x58\x71\xeb\x4f\x37\xff\xa0\x22\x36\xfa\x0e\x81\x91\x1c\xb1\xbb\xc3\x01\x59\x80\xc0\x9e\x04\x1c\x9f\x20\xe2\x42\x8c\xbc\xc8\x8c\xab\x3a\x74\xf6\x95\x30\x76\xb6\x34\x93\x97\x3c\x6d\x74\x1e\xc1\xd3\xbd\x9d\x61\x4b\x9d\xea\x9f\xff\xef\x71\x70\xfe\xbe\xc6\xeb\xfc\xba\x18\x15\xb8\x54\x6c\x8b\xa3\x81\x1e\x3f\xe0\x3e\x9b\x5d\x94\x74\xca\x0c\xcf\x89\x86\x1f\x60\xbd\x13\xc8\x34\x30\x5b\xd5\x89\xab\x1f\x9c\xf8\xe8\x2d\x64\x6a\x59\x64\xfe\x5d\xe0\xcb\xbb\xa1\xf6\xba\x7d\xde\xe0\x7a\xd8\x58\xf8\xbb\x22\x53\x39\x12\xbd\x0e\xa3\xd3\x02\xa1\x38\x9d\xd7\x3d\xef\xb6\xea\x1f\xb1\xe8\xca\x64\x2e\x42\xde\x6a\xca\xd6\x26\xfa\xb0\x79\x00\xa3\x89\xe5\xa2\x07\x11\x6e\x8c\xdc\xac\x2a\xb3\xef\x9a\xcc\xc3\xd8\x87\x6a\x90\xf4")
	seed := []byte("\x42\xb7\x92\x6e\x21\x34\x40\x7c\x91\x9d\xa4\xb7\xa6\xae\xd2\x45\x1d\x4f\x6e\xe8\xaf\x21\x5c\xcc\xf0\x67\x58\x45\x46\x23\xaa\xcf")
	mgf1XOR(out, sha256.New(), seed)
	want := []byte("\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\xc4\xd8\x67\x64\x3b\xf8\xdc\x07\xd4\xb0\x0b\x3b\x4c\x36\x21\x1b\x57\xa6\x9d\xf9\x78\x78\x6a\xfd\xe9\xea\x94\x88\x85\xfd\x59\xfd")
	if got := out; !bytes.Equal(got, want) {
		t.Errorf("result mismatch, got=%x, want=%x", got, want)
	}
}

// incCounter increments a four byte, big-endian counter.
func incCounter(c *[4]byte) {
	if c[3]++; c[3] != 0 {
		return
	}
	if c[2]++; c[2] != 0 {
		return
	}
	if c[1]++; c[1] != 0 {
		return
	}
	c[0]++
}

// mgf1XOR XORs the bytes in out with a mask generated using the MGF1 function
// specified in PKCS #1 v2.1.
func mgf1XOR(out []byte, hash hash.Hash, seed []byte) {
	log.Printf("mgf1XOR out=%x, seed=%x", out, seed)
	var counter [4]byte
	var digest []byte

	done := 0
	for done < len(out) {
		hash.Write(seed)
		hash.Write(counter[0:4])
		digest = hash.Sum(digest[:0])
		hash.Reset()

		for i := 0; i < len(digest) && done < len(out); i++ {
			out[done] ^= digest[i]
			done++
		}
		incCounter(&counter)
	}
	log.Printf("mgf1XOR out=%x", out)
}

func TestBigIntBitLen(t *testing.T) {
	n := new(big.Int)
	n.SetBytes([]byte("\x27\x0d\x69\xe5\xa0\x5d\x8d\x3c\x9c\x0d\x4f\x5e\xae\x24\x3b\xe8\xe4\x51\x61\x9c\x5f\x70\xad\x12\x7c\xbb\x82\x3b\x55\xf9\xfe\x79\xbe\x3d\xa5\xcd\x1e\x6a\xe7\xde\x20\xd8\xd7\x23\x84\x0f\x26\x41\xab\xed\xd4\x72\xd9\xfe\x58\x11\x04\xce\x5f\xb8\xee\x02\xed\x9d\xeb\x46\xb7\x89\x87\x8e\xac\xd0\xe2\x06\x71\xe5\xef\x0a\x51\x3a\x44\x43\xdf\x13\x34\xf2\x2e\x0c\xab\x4c\xc7\x65\xd7\x24\x07\x95\x0a\xd9\xb4\x41\xea\x93\xc5\x85\xe8\x4e\x0b\xe6\xf8\x00\xd7\xae\xd9\x6c\x6d\x01\x35\xaf\x7e\x26\xa5\xfe\xb6\xfa\xfc\xb8\xc1\x44\xe3\xb0\xcc\xce\xdb\x93\x83\xaa\x44\x83\x61\x85\x52\xd3\x78\x7e\x2e\x0f\x76\xc3\xaf\xf4\x2f\xb0\x4b\xbe\xf5\xc0\x75\xbc\x0c\x06\x63\x94\x07\x5b\x12\x33\xa8\xee\xff\xdf\xc2\xdb\x28\xeb\xa3\x69\x27\x5a\x2f\x88\xa0\xa8\x99\xc8\x5c\xe3\x60\x42\x51\x19\xab\xe8\x8a\xd8\x68\xee\xf6\x41\x36\x15\x70\x44\x77\x64\xad\x5d\x75\x72\x1d\x74\xf3\x8e\x82\xb1\x8f\x6a\xcd\xaa\x71\xaa\xd0\xd0\x63\x66\x20\xf8\x4d\x2d\x83\xfe\x64\xf7\xe3\x4c\xb7\x00\x4c\xd2\x3e\xa7\x8f\xbe\xeb\x6a\xce\xe3\xdb\x67\x09\x80\xa6\x23\x50\x83\xd3\x81"))
	if got, want := n.BitLen(), 2046; got != want {
		t.Errorf("BitLen result mismatch, got=%d, want=%d", got, want)
	}
}

func TestRSAPSSSignVerify(t *testing.T) {
	var initial [12]uint32
	rnd := NewRandomForTest(initial)

	// privKey, err := rsa.GenerateKey(&rnd, 2048)
	// if err != nil {
	// 	t.Fatal(err)
	// }
	// privKeyDer := x509.MarshalPKCS1PrivateKey(privKey)
	// log.Printf("privKeyDer=%x", privKeyDer)

	privKeyDer := []byte("\x30\x82\x04\xa4\x02\x01\x00\x02\x82\x01\x01\x00\xd3\x72\xe8\x35\x01\xed\xac\xf7\xe7\xd8\x4f\x70\x77\x2d\xba\x3a\x8c\x50\xaa\x2a\xff\xc4\xb4\xc5\xd5\x51\xb3\xaa\x8e\xea\xf1\xb2\x6f\xd4\x17\xea\x6e\x7d\x00\xb2\xdc\x1b\x94\x4f\xc2\xce\x4d\xd9\x77\xf3\xd3\x58\x75\x73\x44\xd9\xdd\x21\xc4\x41\xf0\xaf\x32\xf2\x7b\x9d\x3f\x1d\xed\xe6\x5f\xc2\x0c\x56\x60\x07\x76\xf3\xfe\x11\x09\x44\x42\x23\x47\x58\xe4\xbc\x02\x91\x91\xbc\xa0\x9c\x50\x64\x8e\x70\xab\x23\x56\x94\xe5\xfa\x8a\x26\xaa\xa8\xf1\xc8\x7e\xe4\xc8\x3b\xb1\xc7\x8b\x44\x44\xd3\x3f\xe6\xe4\xf6\xc5\xb4\x7e\x84\xe3\x8d\xdd\x8a\x10\x35\x7f\xd1\x7f\xb2\x10\x7b\xe5\xaa\xa6\xb8\x1d\x90\x27\x42\x85\x5c\xa9\xf4\xc3\x51\xf4\x2a\x09\x1d\x6c\xfe\x16\xa9\x99\x63\x23\x58\xcf\x20\xfe\xcd\xc0\x95\xe3\xa1\xce\x7e\x5a\x45\x45\xd7\x16\x25\x35\x32\x35\x6b\xc0\x2a\x35\x04\xdf\x54\xc2\x33\x46\xa1\x27\x20\x29\xf1\xa4\xac\x96\xb5\x94\xba\x9c\x26\xa5\xb1\xc6\x4d\x28\xc7\x39\xb8\x65\x7e\x95\xf6\x8b\x0d\x2f\xf1\xb8\xcc\xb2\xa6\x33\x90\xcd\x67\x97\xc5\xe9\x82\x24\x29\xb7\x9f\x1b\x23\x83\x20\x64\xf8\x08\x51\x86\x6f\x47\xed\x04\x19\x9c\x11\x02\x03\x01\x00\x01\x02\x82\x01\x00\x27\x0d\x69\xe5\xa0\x5d\x8d\x3c\x9c\x0d\x4f\x5e\xae\x24\x3b\xe8\xe4\x51\x61\x9c\x5f\x70\xad\x12\x7c\xbb\x82\x3b\x55\xf9\xfe\x79\xbe\x3d\xa5\xcd\x1e\x6a\xe7\xde\x20\xd8\xd7\x23\x84\x0f\x26\x41\xab\xed\xd4\x72\xd9\xfe\x58\x11\x04\xce\x5f\xb8\xee\x02\xed\x9d\xeb\x46\xb7\x89\x87\x8e\xac\xd0\xe2\x06\x71\xe5\xef\x0a\x51\x3a\x44\x43\xdf\x13\x34\xf2\x2e\x0c\xab\x4c\xc7\x65\xd7\x24\x07\x95\x0a\xd9\xb4\x41\xea\x93\xc5\x85\xe8\x4e\x0b\xe6\xf8\x00\xd7\xae\xd9\x6c\x6d\x01\x35\xaf\x7e\x26\xa5\xfe\xb6\xfa\xfc\xb8\xc1\x44\xe3\xb0\xcc\xce\xdb\x93\x83\xaa\x44\x83\x61\x85\x52\xd3\x78\x7e\x2e\x0f\x76\xc3\xaf\xf4\x2f\xb0\x4b\xbe\xf5\xc0\x75\xbc\x0c\x06\x63\x94\x07\x5b\x12\x33\xa8\xee\xff\xdf\xc2\xdb\x28\xeb\xa3\x69\x27\x5a\x2f\x88\xa0\xa8\x99\xc8\x5c\xe3\x60\x42\x51\x19\xab\xe8\x8a\xd8\x68\xee\xf6\x41\x36\x15\x70\x44\x77\x64\xad\x5d\x75\x72\x1d\x74\xf3\x8e\x82\xb1\x8f\x6a\xcd\xaa\x71\xaa\xd0\xd0\x63\x66\x20\xf8\x4d\x2d\x83\xfe\x64\xf7\xe3\x4c\xb7\x00\x4c\xd2\x3e\xa7\x8f\xbe\xeb\x6a\xce\xe3\xdb\x67\x09\x80\xa6\x23\x50\x83\xd3\x81\x02\x81\x81\x00\xd7\x86\xf6\x85\xe5\xfd\x98\xdb\xb1\x5d\x7b\xf5\x1f\xe3\x79\x24\xbe\xc1\x5b\xf0\x86\x16\x65\x7f\x8d\x37\x5e\xac\x0b\xc5\xc7\xd4\x6c\x71\x3b\x2e\xbf\xc2\x83\x5a\x14\xd7\xe0\xf9\x6d\x40\x12\x53\xe0\x2e\xda\x7b\x78\x6c\x1e\x42\x88\xfb\xcf\x74\x2e\x12\xa6\xd7\xc6\x74\x86\x43\xd0\xcb\x5c\x2c\x89\x5b\x6f\x12\x5c\x58\xfe\x6b\xa7\x24\xbf\x9b\x43\x5a\x8f\x0a\xa3\x4e\xd2\xfd\x00\x88\x5e\x3c\xe4\x1e\x2e\xa7\xff\xb1\x95\xa7\x9b\x1f\x81\xe7\xff\xbf\xb4\x6c\x33\x9f\x14\xae\x45\xa6\x81\x33\xbe\x83\x52\x7f\x5b\xb1\xb9\x8d\x02\x81\x81\x00\xfb\x27\xe2\xcb\x22\xe4\x80\xa4\x14\x17\x33\xba\xa0\x07\x92\xb8\xf6\xa1\x58\xb4\x7f\xb3\x3d\x6d\x04\x5f\xec\xa4\x7e\x58\xca\xd7\xc7\xc7\x73\x09\x0a\x72\x05\x55\x5d\x0a\xf7\x3c\xc8\xce\xc7\x10\x05\xf2\x10\x9b\x66\x89\xa9\x71\x7a\x71\xb1\x4f\x4b\x37\xfe\x93\x2c\xcb\x05\xeb\x50\x3c\x84\x32\x46\x97\x8c\xa0\x3e\x42\x15\xdf\x24\x4d\x62\xaa\xa8\x57\x78\xd7\x71\x89\x48\x5c\xcf\x25\x78\x66\x66\x0e\xd4\x68\xc6\x25\xc1\x01\xf8\x27\x49\x60\xdf\x28\x4a\x0e\x38\xc3\xfb\xdc\x54\xd0\x61\x27\x7d\xa6\x41\x7c\x11\x7f\x51\x95\x02\x81\x80\x59\x65\xf1\xfb\xb8\x5a\x68\x7d\x38\x24\xbe\xb5\xfe\x74\x2c\x5b\xc1\x84\x12\xce\xc1\xcf\xa8\x6a\x2f\xf9\x37\x9b\xc5\x86\x54\x4d\x18\x6e\x1f\x4e\x54\xdc\x29\xff\xc3\x85\x88\x1b\xed\xe5\x15\xb5\x14\xd8\x5a\x67\xbc\x9b\x9c\x31\x9d\x00\x56\x1c\xaa\xbf\xb1\xd4\xee\xcc\x86\xa4\xba\x86\x9f\xc5\x19\x74\x83\xad\xea\x00\x40\x08\x07\x5c\x86\xdd\xb0\x22\x70\x12\xc9\x8a\x78\x99\xd9\x0e\xb7\x88\x2a\x57\x1a\xa3\x34\xbc\x44\x87\x31\x20\xf0\x91\x7a\xd3\xd9\xd2\xc7\xd6\xc4\x8d\x44\xf6\xbb\xc0\xea\xd5\x2d\xf3\x05\xe5\xc2\x41\x02\x81\x81\x00\xd9\x86\x15\x16\x2c\xd5\x4d\x59\x4e\x91\x3d\xdb\x40\x28\xee\xf9\xc5\x99\xbe\x93\x2e\x1a\xd6\x73\xaa\x1b\x4e\x80\xb5\x71\x3f\xd5\x9d\x90\xef\xdf\xff\xac\xfb\x53\x90\xaf\x23\xad\x00\x9a\x9e\xac\x11\x0a\x33\x39\xf4\x97\xfc\x2a\x6d\x8b\x34\xaf\x61\x8d\x50\xae\xb5\x57\xed\x7b\x7d\xd5\xbc\x05\x33\x40\xa4\xaa\x50\xe1\xb9\xc1\xb6\xd6\x53\x43\x4d\x63\xdd\x24\x73\x90\x1c\x1d\x4d\xc7\xbd\x3c\xaa\xdd\xe3\x38\x0f\x8d\xb9\x59\x74\x4c\xca\x6f\xdd\x37\x2e\xd4\x9c\x73\x99\x9a\x9d\xd6\x90\x9e\xbc\x63\x97\x49\xd6\x79\xb7\xf5\x02\x81\x81\x00\xcd\xd6\x71\x32\x43\xed\x5f\x95\x4c\x1b\x9a\xfd\x59\xe7\x2f\x9d\x15\x4b\xb8\x46\x48\x2d\x87\xd4\xf8\x8f\x50\x8d\x68\x06\x54\xd1\x35\xd7\x0d\xdf\x3e\xd4\x6d\x2b\xcf\x04\xbc\x1a\x00\x78\x3c\x51\x38\x3a\x4a\xf0\x84\xbb\x87\x93\x7b\xcb\x00\xfa\x70\x3e\xc5\xc2\x17\xcf\xb9\x2a\xce\x76\x4d\x95\x6d\x96\xb5\x66\x1a\x22\x37\xed\xce\xfb\x6d\xb3\x50\xb5\x4f\x4c\xf5\xa3\x45\x61\x62\x93\x09\x9a\xfe\x77\x2b\x92\x0a\x2c\x43\x59\x6b\x4f\xf7\x32\xcd\x3a\xe6\x0d\x37\x7b\xd1\x8e\x42\xd6\x19\x44\x3b\x7e\x46\x71\x00\xf8\x2a\xc9")
	privKey, err := x509.ParsePKCS1PrivateKey(privKeyDer)
	if err != nil {
		t.Fatal(err)
	}
	log.Printf("privKey.D=%x", privKey.D.Bytes())
	// 270d69e5a05d8d3c9c0d4f5eae243be8e451619c5f70ad127cbb823b55f9fe79be3da5cd1e6ae7de20d8d723840f2641abedd472d9fe581104ce5fb8ee02ed9deb46b789878eacd0e20671e5ef0a513a4443df1334f22e0cab4cc765d72407950ad9b441ea93c585e84e0be6f800d7aed96c6d0135af7e26a5feb6fafcb8c144e3b0cccedb9383aa4483618552d3787e2e0f76c3aff42fb04bbef5c075bc0c066394075b1233a8eeffdfc2db28eba369275a2f88a0a899c85ce360425119abe88ad868eef641361570447764ad5d75721d74f38e82b18f6acdaa71aad0d0636620f84d2d83fe64f7e34cb7004cd23ea78fbeeb6acee3db670980a6235083d381

	digest := []byte("\x7f\xdd\xeb\x8d\x8a\x9e\x4c\x5e\x2e\x7e\x8c\x13\x5a\xb8\xf8\xb6\x19\xba\x21\xae\xb5\x2d\x61\xba\x85\xeb\x1e\x29\x28\x32\xe6\x81")

	signOpts := &rsa.PSSOptions{SaltLength: rsa.PSSSaltLengthEqualsHash}
	hash := crypto.SHA256
	sig, err := rsa.SignPSS(&rnd, privKey, hash, digest, signOpts)
	if err != nil {
		t.Fatal(err)
	}
	// log.Printf("sig=%x", sig)
	wantSig := []byte("\x10\x39\x5d\x99\x1e\x59\x91\xdc\x8a\x6e\x8e\x89\xed\x35\xb2\x42\x40\xe5\x32\x8e\xa4\xe0\xb0\xb0\x5f\x96\xd2\x18\xf1\x9f\x7a\x3d\xce\x8b\xee\x9d\x4a\xb9\xf0\x0f\x8b\xa7\xaf\xc9\xf9\x49\xa4\x9a\x02\x44\x55\x8c\xaf\xf6\x7b\xd8\x2e\x8d\x93\xf8\xf6\x22\xc9\x74\x31\x62\x3e\xb3\xa8\x1b\xcf\x1b\x9e\xac\x3f\x19\x3a\x58\xff\x38\x21\xe3\xb6\x52\x2c\xdf\x5c\x45\xf3\x72\x19\x50\xc0\x89\xae\x98\x0d\xb7\xdf\xc5\x5a\xed\xa7\x1d\x29\xe8\x77\x1f\x61\xd9\xaf\x2a\xfc\xb0\xa6\x72\xfe\xa5\x9e\x7c\x26\x3d\x8e\xc1\x3f\x5f\xc5\xdd\x55\xff\xe1\x4e\x7e\x58\xd2\x36\x40\x0c\xd4\xec\x1f\xcb\x0c\xf3\x1b\x28\xd6\x49\xa4\x6b\xe4\x2f\x55\xe1\x43\x4e\xed\x66\xf0\xc0\x51\x3b\x09\x30\x2d\xbb\x0e\xd7\x21\x5f\x3a\x54\xa5\x87\x8d\x3f\x45\xf2\xc7\x36\xd4\xad\x87\x94\x8e\xbf\x4b\x5e\x28\x7c\x30\x9f\xc3\x1e\x1b\xf7\xa4\x5f\x3e\x65\xf3\x92\x2f\x51\xff\xff\xb2\x36\xbe\x95\x18\x6c\xea\xf2\x73\x7a\x0b\x1a\xed\x5b\x49\x7b\xb7\x35\x2a\x14\x9e\x62\xe9\x87\xfe\xe0\x47\x03\xf3\x6d\xe1\x26\x0d\xe4\xd6\xbe\xac\x12\x01\xe0\xec\x8e\xd6\x7c\x22\xb3\x9a\xfb\x42\x3f")
	if got, want := sig, wantSig; !bytes.Equal(got, want) {
		t.Errorf("signature mismatch, got=%x, want=%x", got, want)
	}

	if err := rsa.VerifyPSS(&privKey.PublicKey, hash, digest, sig, signOpts); err != nil {
		t.Errorf("VerifyPSS expected to success, but failed.")
	}
}
